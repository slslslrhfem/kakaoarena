# -*- coding: utf-8 -*-
"""kakao arena.ipynb의 사본

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1skHycEevihzvJ1dZXN1QIOn2orglth3_
"""

import numpy as np
import librosa
import matplotlib.pyplot as plt
import librosa.display

import IPython.display

#위까지가 멜스펙토그램 좀 다뤄본것. 큰의미는 없을듯
import pandas as pd
genre_gn_all=pd.read_json("/content/drive/My Drive/Kakao Arena/genre_gn_all.json",typ='series')
genre_gn_all = pd.DataFrame(genre_gn_all, columns = ['gnr_name']).reset_index().rename(columns = {'index' : 'gnr_code'})
print(genre_gn_all)#전체장르
gnr_code = genre_gn_all[genre_gn_all['gnr_code'].str[-2:] == '00']
print(gnr_code)#대분류장르
dtl_gnr_code = genre_gn_all[genre_gn_all['gnr_code'].str[-2:] != '00']
dtl_gnr_code.rename(columns = {'gnr_code' : 'dtl_gnr_code', 'gnr_name' : 'dtl_gnr_name'}, inplace = True)
print(dtl_gnr_code)#세부장르

gnr_code = gnr_code.assign(join_code = gnr_code['gnr_code'].str[0:4])
dtl_gnr_code = dtl_gnr_code.assign(join_code = dtl_gnr_code['dtl_gnr_code'].str[0:4])

# Merge
gnr_code_tree = pd.merge(gnr_code, dtl_gnr_code, how = 'left', on = 'join_code')

gnr_code_tree[['gnr_code', 'gnr_name', 'dtl_gnr_code', 'dtl_gnr_name']]
gnr_code_tree[gnr_code_tree['gnr_code'] == 'GN0900']
#장르 트리.

import os
song_meta = pd.read_json('/content/drive/My Drive/Kakao Arena/song_meta.json', typ = 'frame')
song_meta

song_meta.info()

a=song_meta.loc[song_meta['id']==325514]
print(a) #곡의 아이디 기반한 정보
a.info()
print(a.iloc[0]['album_id']) #그 후 이런식으로 꺼내면 됨. id가 325514인 곡의 앨범 아이디.
print(song_meta.loc[song_meta['album_id']==40432])#위 아이디로 곡들 불러옴
print(list(song_meta.loc[song_meta['album_id']==40432].iloc[:]['id']))#이렇게 325514 곡과 같은 앨범에 수록된 곡들을 불러올 수 있다.

artists=a.iloc[0]['artist_id_basket']
for artist in artists:
  b=song_meta.loc[song_meta['artist_id_basket'].apply(lambda x: artist in x)]
  print(b) #artist가 해당되는 곡들 불러옴
  print(list(b.iloc[:]['id']))#이렇게 325514 곡과 같은 아티스트가 만든 곡들을 불러올 수 있다.


print(song_meta.loc[song_meta['album_name'].str.match("그남자 그여자").fillna(True)])

song_meta['artist_id_basket'].str.contains('2')

train = pd.read_json('/content/drive/My Drive/Kakao Arena/train.json', typ = 'frame')
print(train)

train.info()

plylst_song_map = train[['id', 'songs']]

# unnest songs
plylst_song_map_unnest = np.dstack(
    (
        np.repeat(plylst_song_map.id.values, list(map(len, plylst_song_map.songs))), 
        np.concatenate(plylst_song_map.songs.values)
    )
)

# unnested 데이터프레임 생성 : plylst_song_map
plylst_song_map = pd.DataFrame(data = plylst_song_map_unnest[0], columns = plylst_song_map.columns)
plylst_song_map['id'] = plylst_song_map['id'].astype(str)
plylst_song_map['songs'] = plylst_song_map['songs'].astype(str)

# unnest 객체 제거
del plylst_song_map_unnest

# 플레이리스트 아이디(id)와 매핑된 태그(tags) 추출
plylst_tag_map = train[['id', 'tags']]

# unnest tags
plylst_tag_map_unnest = np.dstack(
    (
        np.repeat(plylst_tag_map.id.values, list(map(len, plylst_tag_map.tags))), 
        np.concatenate(plylst_tag_map.tags.values)
    )
)

# unnested 데이터프레임 생성 : plylst_tag_map
plylst_tag_map = pd.DataFrame(data = plylst_tag_map_unnest[0], columns = plylst_tag_map.columns)
plylst_tag_map['id'] = plylst_tag_map['id'].astype(str)

# unnest 객체 제거
del plylst_tag_map_unnest

print(plylst_song_map)
print(plylst_tag_map)

test = pd.read_json('/content/drive/My Drive/Kakao Arena/test.json', typ = 'frame')#구현의 편의를 위해 test란 이름 하에 val파일로 바꿈
print(test)
test.info()

print(test.shape[0])

print(test.loc[55,'songs'])
print(test.loc[55,'tags'])
print(test.loc[55,'plylst_title'])
print(test.loc[55,'like_cnt'])
print(test.loc[55,'updt_date'])

import re
title=test.loc[1,'plylst_title']
title=re.sub('[^A-Za-z0-9\u3130-\u318F\uAC00-\uD7A3]', " ", title)
#print(title)   팝 일렉 신나는 분위기를 원할 때
titleword=title.split(' ')
#print(titleword)  ['', '팝', '일렉', '신나는', '분위기를', '원할', '때']
resword=list(filter(('').__ne__, titleword))
print(resword)  #['팝', '일렉', '신나는', '분위기를', '원할', '때']

print(plylst_song_map.loc[plylst_song_map['songs'] == '196298'])
print(plylst_song_map.loc[plylst_song_map['songs'] == '196298']['id'].tolist())
print(train.loc[train['id']==29392])
print(train['tags'])
lists=train.to_numpy()
print(lists.shape)
print(lists[0])

a=train.loc[train['id']==29392]
print(a.columns)
print(a.iloc[0]['songs'])
print(a.loc[:,'tags'])

import pickle
from tqdm import tqdm
tags_answer=[]
songs_answer=[]
lists=train.to_numpy() # (115071,6) size의 구조
a=0
for i in tqdm(range(8999,test.shape[0]),position=0, leave=True):#playlist 하나씩 도는거임 #현재 몇개의 valid파일이 test로 쓰여있다
  if (i%100==99 and a!=0):
    with open('/content/drive/My Drive/Kakao Arena/test/test'+str(i-99)+'~'+str(i)+'taglist.txt', 'wb') as f:
      pickle.dump(tags_answer, f)
    with open('/content/drive/My Drive/Kakao Arena/test/test'+str(i-99)+'~'+str(i)+'songlist.txt', 'wb') as f2:
      pickle.dump(songs_answer, f2)  
    tags_answer=[]
    songs_answer=[]#메모리 관련 이슈로 초기화.
    #100~199와 같은 식으로 파일 이름이 되어있는데 실제로는 99~198일 것 같음.. 큰 상관은 없으나 고려해야할듯

  tags_dict={}
  songs_dict={}
  a=a+1
  plylst_title=test.loc[i,'plylst_title']
  title=re.sub('[^A-Za-z0-9\u3130-\u318F\uAC00-\uD7A3]', " ", plylst_title)
  titleword=title.split(' ')
  resword=list(filter(('').__ne__, titleword))
  for tags in resword:#tags로 써있긴 하지만 플레이리스트 제목에 기반해서 사용.
    for lst in lists:
      if (tags in lst[0]):
        for traintags in lst[0]:
          traintags=str(traintags)+'titleplylst'
          if traintags in tags_dict:
            tags_dict[traintags]+=1
          else:
            tags_dict[traintags]=1
        for trainsongs in lst[3]:
          trainsongs=str(trainsongs)+'titleplylst'
          if trainsongs in songs_dict:
            songs_dict[trainsongs]+=1
          else:
            songs_dict[trainsongs]=1

  for songs in test.loc[i,'songs']:#플레이 리스트마다 50번 도는거임. 50번 아닐수도 있더군요..
    now_metadata=song_meta.loc[song_meta['id']==songs]
    now_albumid=now_metadata.iloc[0]['album_id']
    albumsong_list=list(song_meta.loc[song_meta['album_id']==now_albumid].iloc[:]['id'])
    for trainsongs in albumsong_list:
      trainsongs=str(trainsongs)+'albumsong'
      if trainsongs in songs_dict:
        songs_dict[trainsongs]+=1
      else:
        songs_dict[trainsongs]=1

    now_artistids=now_metadata.iloc[0]['artist_id_basket']

    for artist in now_artistids:
      now_artistsongs=song_meta.loc[song_meta['artist_id_basket'].apply(lambda x: artist in x)]
      artistsong_list=list(now_artistsongs.iloc[:]['id'])
      for trainsongs in artistsong_list:
        trainsongs=str(trainsongs)+'artistsong'
        if trainsongs in songs_dict:
          songs_dict[trainsongs]+=1
        else:
          songs_dict[trainsongs]=1
    plylsts_songs=plylst_song_map.loc[plylst_song_map['songs'] == str(songs)]#이 곡을 가지고 있는 플레이 리스트의 song_map 데이터프레임.
    if not plylsts_songs.empty:#비어있으면 별도의 작업을 하지 않음.. 머리가 아픕니다 근데 exception안해도 그냥 돌아가는 듯 보입니다.
      id_lists=plylsts_songs['id'].tolist()
      for ids in id_lists:# 이 아이디들은 playlist의 아이디들이다. str으로 주어진다.
        id_train=train.loc[train['id']==int(ids)]
        for trainsongs in id_train.iloc[0]['songs']:
          trainsongs=str(trainsongs)+'songplylst'
          if trainsongs in songs_dict:
            songs_dict[trainsongs]+=1
          else:
            songs_dict[trainsongs]=1
        for traintags in id_train.iloc[0]['tags']:
          traintags=str(traintags)+'songplylst'
          if traintags in tags_dict:
            tags_dict[traintags]+=1
          else:
            tags_dict[traintags]=1
    
    """
    a=song_meta.loc[song_meta['id']==325514]
print(a) #곡의 아이디 기반한 정보
a.info()
print(a.iloc[0]['album_id']) #그 후 이런식으로 꺼내면 됨. id가 325514인 곡의 앨범 아이디.
print(song_meta.loc[song_meta['album_id']==40432])#위 아이디로 곡들 불러옴
print(list(song_meta.loc[song_meta['album_id']==40432].iloc[:]['id']))#이렇게 325514 곡과 같은 앨범에 수록된 곡들을 불러올 수 있다.

artists=a.iloc[0]['artist_id_basket']
for artist in artists:
  b=song_meta.loc[song_meta['artist_id_basket'].apply(lambda x: artist in x)]
  print(b) #artist가 해당되는 곡들 불러옴
  print(list(b.iloc[:]['id']))#이렇게 325514 곡과 같은 아티스트가 만든 곡들을 불러올 수 있다.


print(song_meta.loc[song_meta['album_name'].str.match("그남자 그여자").fillna(True)])
    """
    
  # 위 포문은 리스트에 있는 곡들을 포함하는 다른 플레이리스트를 train에서 찾고,
  # 그 플레이 리스트의 태그와 곡들을 넣는겁니다.
  #songplylst가 붙은 키가 이 방식으로 가감이 된 것을 의미합니다.

  #print(tags_dict)
  #print(songs_dict)
  #print("다음 값은 tags도 고려됩니다 a=1")

  a=1#원래 파라미터 관해서 커버하려고 했는데 방식이 바뀌어서 그냥 1임
  for tags in test.loc[i,'tags']:#플레이리스트 마다 플레이리스트의 태그를 가져옴.
    #주의할점은 여기서는 np array를 통해 직접 들고옵니다 string list가지고 핸들링하는거 어려움..
    #프린트를 해보니 태그쪽이 수가 곡보다 적음에도 일반적으로 영향력이 3~4배정도 커보임 수록곡 1등인 밤편지가 2000개 리스트에 있는데
    #사랑 이런 태그는 막 10000개 가까이 있지 않을까 예상중. 일단은 parameter수정없이 함.
    for lst in lists:
      if (tags in lst[0]):
        for traintags in lst[0]:
          traintags=str(traintags)+'tagplylst'
          if traintags in tags_dict:
            tags_dict[traintags]+=a
          else:
            tags_dict[traintags]=a
        for trainsongs in lst[3]:
          trainsongs=str(trainsongs)+'tagplylst'
          if trainsongs in songs_dict:
            songs_dict[trainsongs]+=a
          else:
            songs_dict[trainsongs]=a
    
  tags_answer.append(tags_dict)
  songs_answer.append(songs_dict)
  #print(tags_dict)
  #print(songs_dict)
with open('/content/drive/My Drive/Kakao Arena/test/test'+str(i-99)+'~'+str(i)+'taglist.txt', 'wb') as f:
  pickle.dump(tags_answer, f)
with open('/content/drive/My Drive/Kakao Arena/test/test'+str(i-99)+'~'+str(i)+'songlist.txt', 'wb') as f2:
  pickle.dump(songs_answer, f2)  
  """
    print(train.loc[train['id']==10532])
    a=train.loc[train['id']==10532]
    print(a.loc[1,'songs'])
    print(a.loc[1,'tags'])
  """



from tqdm import tqdm
import pickle
import json

tagplylst_parameter=10
songplylst_parameters=[30]
titleplylst_parameters=[3,50]
albumsong_parameters=[3,150]
artistsong_parameters=[3,150]
before_songs=[362966, 576559, 514079, 427902, 272180, 110239, 135447, 472490, 106573, 369127, 163377, 18418, 228263, 347448, 42317, 252577, 317711, 360373, 699518, 64641, 200687, 54755, 496394, 108207, 124823, 524956, 658227, 305183, 11093, 335756, 74638, 704707, 518420, 528397, 191236, 349270, 161288, 529748, 618742, 448682, 108003, 569401, 443914, 646941, 254865, 204439, 200059, 342798, 205179, 675874, 275121, 277034, 498452, 659226, 521330, 580326, 119974, 3805, 699874, 704752, 114119, 532044, 584067, 133190, 563098, 93143, 318530, 493762, 603633, 420396, 347585, 191915, 222272, 130199, 355939, 259795, 581799, 553166, 493804, 423821, 410890, 307179, 195174, 475599, 19364, 375431, 405604, 445170, 436741, 378434, 588471, 459256, 138486, 32570, 52904, 417071, 654112, 643498, 455744, 146989]
before_tags=["kpop", "BTS", "스트레스", "방탄", "신나는", "기분전환", "드라이브", "여행", "운동", "감성"]
tags='추억' # 가장 처음부터 터지는 case 방지용 
#id=test.loc[i,'id']
for songplylst_parameter in songplylst_parameters:
  for titleplylst_parameter in titleplylst_parameters:
    for albumsong_parameter in albumsong_parameters:
      for artistsong_parameter in artistsong_parameters:
        print('now is for ',songplylst_parameter, titleplylst_parameter, albumsong_parameter, artistsong_parameter)
        answer_dicts=[]
        for i in tqdm(range(test.shape[0]),leave=True, position=0):
          if (i%100==99):
            parttag=[]
            partsong=[]
            with open('/content/drive/My Drive/Kakao Arena/test/test'+str(i-99)+'~'+str(i)+'taglist.txt', 'rb') as f:#tag
              subparttag=pickle.load(f)
            with open('/content/drive/My Drive/Kakao Arena/test/test'+str(i-99)+'~'+str(i)+'songlist.txt', 'rb') as f2:#song
              subpartsong=pickle.load(f2)
            for dicts in subparttag: #dictionary 보통 100개 불러옴
              new_dicts={}
              for key,val in dicts.items():
                if 'tagplylst' in key:
                  new_key=key.replace('tagplylst','')
                  if new_key not in new_dicts:
                    new_dicts[new_key]=tagplylst_parameter*val
                  else:
                    new_dicts[new_key]+=(tagplylst_parameter*val)
                elif 'titleplylst' in key:
                  new_key=key.replace('titleplylst','')
                  if new_key not in new_dicts:
                    new_dicts[new_key]=titleplylst_parameter*val
                  else:
                    new_dicts[new_key]+=(titleplylst_parameter*val)
                elif 'songplylst' in key:
                  new_key=key.replace('songplylst','')
                  if new_key not in new_dicts:
                    new_dicts[new_key]=songplylst_parameter*val
                  else:
                    new_dicts[new_key]+=(songplylst_parameter*val)
              parttag.append(new_dicts)
            for dicts in subpartsong: #dictionary 보통 100개 불러옴
              song_new_dicts={}
              for key,val in dicts.items():
                if 'tagplylst' in key:
                  new_key=key.replace('tagplylst','')
                  if new_key not in song_new_dicts:
                    song_new_dicts[new_key]=tagplylst_parameter*val
                  else:
                    song_new_dicts[new_key]+=(tagplylst_parameter*val)
                elif 'titleplylst' in key:
                  new_key=key.replace('titleplylst','')
                  if new_key not in song_new_dicts:
                    song_new_dicts[new_key]=titleplylst_parameter*val
                  else:
                    song_new_dicts[new_key]+=(titleplylst_parameter*val)
                elif 'songplylst' in key:
                  new_key=key.replace('songplylst','')
                  if new_key not in song_new_dicts:
                    song_new_dicts[new_key]=songplylst_parameter*val
                  else:
                    song_new_dicts[new_key]+=(songplylst_parameter*val)
                elif 'artistsong' in key:
                  new_key=key.replace('artistsong','')
                  if new_key not in song_new_dicts:
                    song_new_dicts[new_key]=artistsong_parameter*val
                  else:
                    song_new_dicts[new_key]+=(artistsong_parameter*val)
                elif 'albumsong' in key:
                  new_key=key.replace('albumsong','')
                  if new_key not in song_new_dicts:
                    song_new_dicts[new_key]=albumsong_parameter*val
                  else:
                    song_new_dicts[new_key]+=(albumsong_parameter*val)
              partsong.append(song_new_dicts)
              #이제 이게 subparttag는 키가 196264tagplaylst 이런식으로 되어있고, partsong은 196264가 들어가야한다.
            for j in range(len(parttag)):#보통 100, song이나 tag나 상관 없다.
              
              ith_answer={}
              pred_songs=[]
              pred_tags=[]
              songnum=0
              tagnum=0
              for songs in test.loc[i-len(parttag)+j,"songs"]:
                pred_songs.append(songs)
                songnum=songnum+1
              for tags in test.loc[i-len(parttag)+j,"tags"]:
                pred_tags.append(tags)
                tagnum=tagnum+1
              ressongs=dict(sorted(partsong[j].items(),key=(lambda x:x[1]),reverse=True))
              restags=dict(sorted(parttag[j].items(),key=(lambda x:x[1]),reverse=True))
              while True:
                if(songnum==100):
                  break
                #업데이트 날짜는 여기서 고려 가능
                for key in ressongs:
                  key=int(key)
                  if (key not in pred_songs):
                    pred_songs.append(key)
                    songnum+=1
                    if songnum==100:
                      break
                
                if (songnum!=100):
                  pred_songs=before_songs
                  songnum=100
                
                break
              while True:
                if(tagnum==10):
                  break
                for key in restags:
                  if key not in pred_tags:
                    pred_tags.append(key)
                    tagnum=tagnum+1
                    if (tagnum==10):
                      break
                
                if(tagnum!=10):
                  pred_tags=before_tags
                  tagnum=10
                
                break
              id=test.loc[i-len(parttag)+j,'id']
              ith_answer['id']=int(id)
              ith_answer['songs']=pred_songs
              ith_answer['tags']=pred_tags
              answer_dicts.append(ith_answer)
        with open('/content/drive/My Drive/Kakao Arena/test/test'+str(i-99)+'~'+str(i)+'taglist.txt', 'rb') as f:
          subparttag=pickle.load(f)
        with open('/content/drive/My Drive/Kakao Arena/test/test'+str(i-99)+'~'+str(i)+'songlist.txt', 'rb') as f2:
          subpartsong=pickle.load(f2)
        parttag=[]
        partsong=[]
        i=i+1
        for dicts in subparttag: #dictionary 보통 100개 불러옴
          new_dicts={}
          for key,val in dicts.items():
            if 'tagplylst' in key:
              new_key=key.replace('tagplylst','')
              if new_key not in new_dicts:
                new_dicts[new_key]=tagplylst_parameter*val
              else:
                new_dicts[new_key]+=(tagplylst_parameter*val)
            elif 'titleplylst' in key:
              new_key=key.replace('titleplylst','')
              if new_key not in new_dicts:
                new_dicts[new_key]=titleplylst_parameter*val
              else:
                new_dicts[new_key]+=(titleplylst_parameter*val)
            elif 'songplylst' in key:
              new_key=key.replace('songplylst','')
              if new_key not in new_dicts:
                new_dicts[new_key]=songplylst_parameter*val
              else:
                new_dicts[new_key]+=(songplylst_parameter*val)
          parttag.append(new_dicts)
        for dicts in subpartsong: #dictionary 보통 100개 불러옴
          song_new_dicts={}
          for key,val in dicts.items():
            if 'tagplylst' in key:
              new_key=key.replace('tagplylst','')
              if new_key not in song_new_dicts:
                song_new_dicts[new_key]=tagplylst_parameter*val
              else:
                song_new_dicts[new_key]+=(tagplylst_parameter*val)
            elif 'titleplylst' in key:
              new_key=key.replace('titleplylst','')
              if new_key not in song_new_dicts:
                song_new_dicts[new_key]=titleplylst_parameter*val
              else:
                song_new_dicts[new_key]+=(titleplylst_parameter*val)
            elif 'songplylst' in key:
              new_key=key.replace('songplylst','')
              if new_key not in song_new_dicts:
                song_new_dicts[new_key]=songplylst_parameter*val
              else:
                song_new_dicts[new_key]+=(songplylst_parameter*val)
            elif 'artistsong' in key:
              new_key=key.replace('artistsong','')
              if new_key not in song_new_dicts:
                song_new_dicts[new_key]=artistsong_parameter*val
              else:
                song_new_dicts[new_key]+=(artistsong_parameter*val)
            elif 'albumsong' in key:
              new_key=key.replace('albumsong','')
              if new_key not in song_new_dicts:
                song_new_dicts[new_key]=albumsong_parameter*val
              else:
                song_new_dicts[new_key]+=(albumsong_parameter*val)
          partsong.append(song_new_dicts)
        for j in range(len(parttag)):#보통 100, song이나 tag나 상관 없다.
          ith_answer={}
          pred_songs=[]
          pred_tags=[]
          songnum=0
          tagnum=0
          for songs in test.loc[i-len(parttag)+j,"songs"]:
            songs=int(songs)
            pred_songs.append(songs)
            songnum=songnum+1
          for tags in test.loc[i-len(parttag)+j,"tags"]:
            pred_tags.append(tags)
            tagnum=tagnum+1
          ressongs=dict(sorted(partsong[j].items(),key=(lambda x:x[1]),reverse=True))
          restags=dict(sorted(parttag[j].items(),key=(lambda x:x[1]),reverse=True))
          while True:
            if(songnum==100):
                  break
            #업데이트 날짜는 여기서 고려 가능
            for key in ressongs:
              key=int(key)
              if key not in pred_songs:
                pred_songs.append(key)
                songnum=songnum+1
                if (songnum==100):
                  break
                  
            if(songnum!=100):
              pred_songs=before_songs
              songnum=100
            
            break
          while True:
            if(tagnum==10):
                  break
            for key in restags:
              if key not in pred_tags:
                pred_tags.append(key)
                tagnum=tagnum+1
                if (tagnum==10):
                  break
            if(tagnum!=10):
              pred_tags=before_tags
              tagnum=10
            
            break
          id=test.loc[i-len(parttag)+j,'id']
          ith_answer['id']=int(id)
          ith_answer['songs']=pred_songs
          ith_answer['tags']=pred_tags
          answer_dicts.append(ith_answer)
        with open('/content/drive/My Drive/Kakao Arena/test/'+str(tagplylst_parameter)+str(songplylst_parameter)+str(titleplylst_parameter)
+str(albumsong_parameter)+str(artistsong_parameter)+'results.json', 'w',encoding='utf-8') as fp:
            json.dump(answer_dicts, fp,ensure_ascii=False)

with open('/content/drive/My Drive/Kakao Arena/'+str(tagplylst_parameter)+str(songplylst_parameter)+str(titleplylst_parameter)
+str(albumsong_parameter)+str(artistsong_parameter)+'results.json', 'w') as fp:
    json.dump(answer_dicts, fp)

#tot_songs[i]가 dict가 담겨있고(곡id : 숫자 형태) 숫자가 제일 높은 곡 id n개를 일단 잡으면 된다.
for i in range(test.shape[0]):
  answer_dict={}
  pred_songs=[]
  pred_tags=[]
  id=test.loc[i,'id']
  pred_songs.extend(test.loc[i,'songs'])
  pred_tags.extend(test.loc[i,'tags'])
  songs in test.loc[i,'songs']:#플레이 리스트마다 50번 도는거임. 50번 아닐수도 있더군요..